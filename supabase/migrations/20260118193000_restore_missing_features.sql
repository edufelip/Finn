-- Restore presence, notifications feed, comments user nullable, and user asset cleanup triggers.

create extension if not exists pg_net;

-- Presence + notification prefs
alter table public.profiles
  add column if not exists online_visible boolean,
  add column if not exists last_seen_at timestamptz,
  add column if not exists notifications_enabled boolean;

alter table public.profiles
  alter column online_visible set default true,
  alter column notifications_enabled set default true,
  alter column last_seen_at set default now();

update public.profiles
  set last_seen_at = coalesce(last_seen_at, created_at, now());

alter table public.profiles
  alter column last_seen_at set not null,
  alter column online_visible set not null,
  alter column notifications_enabled set not null;

create index if not exists idx_profiles_last_seen_at on public.profiles (last_seen_at desc);

-- Allow comments to survive user deletion by nulling user_id.
alter table public.comments
  alter column user_id drop not null;

alter table public.comments
  drop constraint if exists comments_user_id_fkey;

alter table public.comments
  add constraint comments_user_id_fkey
  foreign key (user_id)
  references public.profiles(id)
  on delete set null;

-- Ensure likes table exists before wiring notification triggers.
create table if not exists public.likes (
  id bigserial primary key,
  post_id bigint not null references public.posts(id) on delete cascade,
  user_id uuid not null references public.profiles(id) on delete cascade,
  created_at timestamptz not null default now(),
  unique (post_id, user_id)
);

alter table public.likes enable row level security;

do $$
begin
  if not exists (
    select 1
    from pg_policies
    where schemaname = 'public'
      and tablename = 'likes'
      and policyname = 'likes_select_authenticated'
  ) then
    create policy "likes_select_authenticated"
      on public.likes
      for select
      to authenticated
      using (true);
  end if;

  if not exists (
    select 1
    from pg_policies
    where schemaname = 'public'
      and tablename = 'likes'
      and policyname = 'likes_insert_own'
  ) then
    create policy "likes_insert_own"
      on public.likes
      for insert
      to authenticated
      with check (auth.uid() = user_id);
  end if;

  if not exists (
    select 1
    from pg_policies
    where schemaname = 'public'
      and tablename = 'likes'
      and policyname = 'likes_delete_own'
  ) then
    create policy "likes_delete_own"
      on public.likes
      for delete
      to authenticated
      using (auth.uid() = user_id);
  end if;
end
$$;

-- Ensure no self-follow constraint exists.
do $$
begin
  if not exists (
    select 1
    from pg_constraint
    where conname = 'user_follows_no_self_follow'
      and conrelid = 'public.user_follows'::regclass
  ) then
    alter table public.user_follows
      add constraint user_follows_no_self_follow
      check (follower_id <> following_id);
  end if;
end
$$;

-- Ensure notifications table exists.
create table if not exists public.notifications (
  id bigint generated by default as identity primary key,
  recipient_id uuid not null references public.profiles(id) on delete cascade,
  actor_id uuid not null references public.profiles(id) on delete cascade,
  type text not null check (type in ('follow', 'post_like', 'post_comment')),
  post_id bigint references public.posts(id) on delete cascade,
  metadata jsonb,
  created_at timestamptz not null default now(),
  read_at timestamptz
);

alter table public.notifications enable row level security;

do $$
begin
  if not exists (
    select 1
    from pg_policies
    where schemaname = 'public'
      and tablename = 'notifications'
      and policyname = 'notifications_select_own'
  ) then
    create policy "notifications_select_own"
      on public.notifications
      for select
      to authenticated
      using (auth.uid() = recipient_id);
  end if;

  if not exists (
    select 1
    from pg_policies
    where schemaname = 'public'
      and tablename = 'notifications'
      and policyname = 'notifications_insert_own'
  ) then
    create policy "notifications_insert_own"
      on public.notifications
      for insert
      to authenticated
      with check (auth.uid() = actor_id);
  end if;

  if not exists (
    select 1
    from pg_policies
    where schemaname = 'public'
      and tablename = 'notifications'
      and policyname = 'notifications_update_own'
  ) then
    create policy "notifications_update_own"
      on public.notifications
      for update
      to authenticated
      using (auth.uid() = recipient_id);
  end if;
end
$$;

create index if not exists idx_notifications_recipient_id
  on public.notifications (recipient_id, created_at desc);

-- Notifications feed helpers + triggers
create or replace function public.create_follow_notification()
returns trigger
language plpgsql
security definer
set search_path = public
as $$
declare
  recipient uuid;
begin
  recipient := new.following_id;

  if recipient is null or recipient = new.follower_id then
    return new;
  end if;

  insert into public.notifications (recipient_id, actor_id, type)
  values (recipient, new.follower_id, 'follow');

  return new;
end;
$$;

create or replace function public.create_like_notification()
returns trigger
language plpgsql
security definer
set search_path = public
as $$
declare
  recipient uuid;
begin
  select user_id into recipient from public.posts where id = new.post_id;

  if recipient is null or recipient = new.user_id then
    return new;
  end if;

  insert into public.notifications (recipient_id, actor_id, type, post_id)
  values (recipient, new.user_id, 'post_like', new.post_id);

  return new;
end;
$$;

create or replace function public.create_comment_notification()
returns trigger
language plpgsql
security definer
set search_path = public
as $$
declare
  recipient uuid;
  preview text;
begin
  select user_id into recipient from public.posts where id = new.post_id;

  if recipient is null or recipient = new.user_id then
    return new;
  end if;

  preview := left(new.content, 140);

  insert into public.notifications (recipient_id, actor_id, type, post_id, metadata)
  values (recipient, new.user_id, 'post_comment', new.post_id, jsonb_build_object('comment_preview', preview));

  return new;
end;
$$;

drop trigger if exists trg_notify_follow on public.user_follows;
create trigger trg_notify_follow
  after insert on public.user_follows
  for each row execute function public.create_follow_notification();

drop trigger if exists trg_notify_like on public.likes;
create trigger trg_notify_like
  after insert on public.likes
  for each row execute function public.create_like_notification();

drop trigger if exists trg_notify_comment on public.comments;
create trigger trg_notify_comment
  after insert on public.comments
  for each row execute function public.create_comment_notification();

create index if not exists idx_notifications_recipient_unread
  on public.notifications (recipient_id, read_at);

-- Trigger cleanup of user assets after profile deletion via edge function.
create or replace function public.trigger_delete_user_assets()
returns trigger
language plpgsql
security definer
as $$
declare
  endpoint text;
  anon_key text;
  payload jsonb;
begin
  endpoint := current_setting('app.settings.delete_user_assets_url', true);
  anon_key := current_setting('app.settings.anon_key', true);

  if endpoint is null or endpoint = '' then
    return old;
  end if;

  payload := jsonb_build_object('userId', old.id);

  perform net.http_post(
    url := endpoint,
    headers := jsonb_build_object(
      'Content-Type', 'application/json',
      'Authorization', 'Bearer ' || coalesce(anon_key, '')
    ),
    body := payload
  );

  return old;
end;
$$;

drop trigger if exists delete_user_assets_trigger on public.profiles;
create trigger delete_user_assets_trigger
after delete on public.profiles
for each row
execute function public.trigger_delete_user_assets();
